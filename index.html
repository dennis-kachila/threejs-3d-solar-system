<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Solar System with Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; }
    canvas { display: block; }
    .label {
      color: white;
      font-family: Arial, sans-serif;
      font-size: 12px;
      padding: 2px 4px;
      background: rgba(0,0,0,0.6);
      border-radius: 3px;
      position: absolute;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="debug" style="position: fixed; top: 10px; left: 10px; color: white; z-index: 100; background: rgba(0,0,0,0.5); padding: 10px;">
    Debugging Information Will Appear Here
  </div>

  <!-- Load Three.js directly from unpkg CDN which is more reliable -->
  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.153.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Debug function
    const debugElement = document.getElementById('debug');
    function log(message) {
      console.log(message);
      debugElement.innerHTML += `<div>${message}</div>`;
    }

    // Global variables that need to be accessed by animate()
    let scene, camera, renderer, controls, sun, planets, clock;
    let planetLabels = []; // Array to store planet label elements

    // Wait for DOM and scripts to load completely
    window.onload = function() {
      // Check if THREE is loaded
      if (typeof THREE === 'undefined') {
        log('ERROR: THREE is not defined - Three.js library not loaded correctly');
      } else {
        log('THREE.js loaded successfully');
        log(`THREE.js version: ${THREE.REVISION}`);
        initScene();
      }
    };

    function initScene() {
      try {
        // Setup scene, camera, renderer
        log('Creating scene...');
        scene = new THREE.Scene();
        log('Scene created');

        log('Creating camera...');
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 30, 120);  // Position camera better for initial view
        log('Camera created and positioned');

        log('Creating renderer...');
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000); // Ensure background is black
        document.body.appendChild(renderer.domElement);
        log('Renderer created and attached to DOM');

        // Check WebGL compatibility
        if (!renderer.capabilities.isWebGL2) {
          log('WARNING: WebGL2 not supported. Using WebGL1 fallback');
        }

        // Implement simple keyboard controls as fallback
        log('Setting up keyboard controls as fallback...');
        let cameraRotationY = 0;
        let cameraDistance = 120;
        let cameraHeight = 30;

        document.addEventListener('keydown', function(event) {
          // Arrow keys for rotation
          if(event.key === 'ArrowLeft') cameraRotationY -= 0.1;
          if(event.key === 'ArrowRight') cameraRotationY += 0.1;
          
          // + and - for zoom
          if(event.key === '+' || event.key === '=') cameraDistance -= 5;
          if(event.key === '-') cameraDistance += 5;
          
          // Up and down arrows for height
          if(event.key === 'ArrowUp') cameraHeight += 5;
          if(event.key === 'ArrowDown') cameraHeight -= 5;
          
          // Constrain values
          cameraDistance = Math.max(20, Math.min(200, cameraDistance));
          cameraHeight = Math.max(-50, Math.min(100, cameraHeight));
          
          // Update camera position
          camera.position.x = Math.sin(cameraRotationY) * cameraDistance;
          camera.position.z = Math.cos(cameraRotationY) * cameraDistance;
          camera.position.y = cameraHeight;
          camera.lookAt(0, 0, 0);
        });
        log('Keyboard controls set up (Use Arrow keys, +, -)');

        // Fixed OrbitControls initialization - try with a different technique
        log('Checking OrbitControls...');
        controls = null;
        if (typeof THREE.OrbitControls === 'undefined') {
          log('OrbitControls not available via THREE.OrbitControls');
          // Try the module approach as a fallback
          if (window.THREE && window.THREE.OrbitControls) {
            log('Found OrbitControls via window.THREE.OrbitControls');
            controls = new window.THREE.OrbitControls(camera, renderer.domElement);
          } else {
            log('ERROR: OrbitControls not found. Using keyboard controls instead.');
          }
        } else {
          log('OrbitControls available');
          controls = new THREE.OrbitControls(camera, renderer.domElement);
        }

        if (controls) {
          controls.target.set(0, 0, 0);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.screenSpacePanning = false;
          controls.minDistance = 10;
          controls.maxDistance = 200;
          controls.update();
          log('OrbitControls created successfully');
        } else {
          log('Using keyboard controls instead of OrbitControls');
          // Update initial camera position to match our fallback controls
          camera.position.x = Math.sin(cameraRotationY) * cameraDistance;
          camera.position.z = Math.cos(cameraRotationY) * cameraDistance;
          camera.position.y = cameraHeight;
          camera.lookAt(0, 0, 0);
        }

        // Lighting: Point light to simulate sun light & ambient light
        log('Adding lights...');
        const pointLight = new THREE.PointLight(0xffffff, 2, 300);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
        log('Lights added');

        // Helper function to create a planet
        function createPlanet(radius, color, distanceFromSun, name) {
          const geometry = new THREE.SphereGeometry(radius, 32, 32);
          const material = new THREE.MeshStandardMaterial({ color });
          const mesh = new THREE.Mesh(geometry, material);

          mesh.userData = { 
            distance: distanceFromSun,
            name: name
          };
          
          // Create a label for the planet
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = name;
          label.style.display = 'none'; // Hide initially until position is calculated
          document.body.appendChild(label);
          
          planetLabels.push({ element: label, planet: mesh });
          
          return mesh;
        }

        // Sun
        log('Creating sun...');
        const sunGeometry = new THREE.SphereGeometry(8, 64, 64);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
        sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        log('Sun created');

        // Planets data: [radius, color, distanceFromSun, orbitSpeed, name]
        const planetsData = [
          { radius: 0.8, color: 0x8a8a8a, distance: 12, speed: 0.04, name: "Mercury" },
          { radius: 1.2, color: 0xffd699, distance: 16, speed: 0.015, name: "Venus" },
          { radius: 1.3, color: 0x2233ff, distance: 20, speed: 0.01, name: "Earth" },
          { radius: 1.0, color: 0xff3300, distance: 24, speed: 0.008, name: "Mars" },
          { radius: 3.5, color: 0xffccaa, distance: 32, speed: 0.005, name: "Jupiter" },
          { radius: 2.9, color: 0xeecc66, distance: 38, speed: 0.004, name: "Saturn" },
          { radius: 2.0, color: 0x99ccff, distance: 44, speed: 0.003, name: "Uranus" },
          { radius: 1.8, color: 0x3355dd, distance: 50, speed: 0.002, name: "Neptune" }
        ];

        planets = [];

        log('Creating planets...');
        planetsData.forEach((data) => {
          const planet = createPlanet(data.radius, data.color, data.distance, data.name);
          scene.add(planet);
          planet.userData.speed = data.speed;
          planets.push(planet);
          
          // Initialize planet positions
          const angle = Math.random() * Math.PI * 2;
          planet.position.x = Math.cos(angle) * data.distance;
          planet.position.z = Math.sin(angle) * data.distance;
        });
        log(`${planets.length} planets created`);

        clock = new THREE.Clock();
        log('Animation clock started');

        // REMOVED: Axes helper that was causing the three lines from the sun (will be removed later)
        // Add axes helper to visualize coordinate axes
        log('Adding axes helper...');
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);
        log('Axes helper added');
        // Add star field background with varying illumination
        log('Adding star background with varying illumination...');
        const starsGeometry = new THREE.BufferGeometry();
        
        const starsVertices = [];
        const starColors = [];
        
        for (let i = 0; i < 3000; i++) {
          const x = Math.random() * 2000 - 1000;
          const y = Math.random() * 2000 - 1000;
          const z = Math.random() * 2000 - 1000;
          starsVertices.push(x, y, z);
          
          // Add varying illumination to stars
          const brightness = Math.random() * 0.5 + 0.5; // Random brightness between 0.5 and 1.0
          starColors.push(brightness, brightness, brightness); // RGB values
        }
        
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        
        const starMaterial = new THREE.PointsMaterial({
          size: 0.7,
          sizeAttenuation: false,
          vertexColors: true, // Enable vertex colors
          transparent: true,
          opacity: 0.8
        });
        
        const starField = new THREE.Points(starsGeometry, starMaterial);
        scene.add(starField);
        log('Star background with varying illumination added');

        log('Starting animation loop');
        animate();
        log('Animation started');
        
        // Final instructions for user
        log('If you see a black screen, try using keyboard controls:');
        log('- Arrow Left/Right: Rotate camera');
        log('- Arrow Up/Down: Adjust camera height');
        log('- +/-: Zoom in/out');

        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          log('Window resized, renderer updated');
        });

      } catch (error) {
        log(`ERROR: ${error.message}`);
        console.error(error);
      }
    }

    function animate() {
      try {
        requestAnimationFrame(animate);
        
        if (!clock) {
          log("ERROR: Animation variables not initialized");
          return;
        }
        
        const elapsed = clock.getElapsedTime();

        sun.rotation.y += 0.004;

        planets.forEach((planet) => {
          const speed = planet.userData.speed;
          const distance = planet.userData.distance;
          planet.position.x = Math.cos(elapsed * speed * 2 * Math.PI) * distance;
          planet.position.z = Math.sin(elapsed * speed * 2 * Math.PI) * distance;
          planet.rotation.y += 0.01;
        });
        
        // Update planet labels
        updatePlanetLabels();

        if (controls) {
          controls.update();
        }

        renderer.render(scene, camera);
      } catch (error) {
        log(`ERROR in animation: ${error.message}`);
        console.error(error);
      }
    }
    
    // Function to update planet label positions
    function updatePlanetLabels() {
      // For each planet label
      planetLabels.forEach(({ element, planet }) => {
        // Convert 3D position to 2D screen position
        const position = new THREE.Vector3(planet.position.x, planet.position.y + 1.5, planet.position.z);
        position.project(camera);
        
        // Calculate screen coordinates
        const x = (position.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-position.y * 0.5 + 0.5) * window.innerHeight;
        
        // Only show labels if they're in front of the camera (not behind)
        if (position.z < 1) {
          element.style.display = 'block';
          element.style.left = x + 'px';
          element.style.top = y + 'px';
        } else {
          element.style.display = 'none';
        }
      });
    }
  </script>
</body>
</html>
